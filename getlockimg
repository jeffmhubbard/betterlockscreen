#!/usr/bin/env bash

set -eu

PROCESSED_SINGLES=()
IMAGE_PATHS=()
DISPLAY_SIZES=()
DISPLAY_OFFSETS=()
EFFECT=none

get_composed_filename() {
	local digest=$(echo $EFFECT ${PROCESSED_SINGLES[@]} ${DISPLAY_OFFSETS[@]} | md5sum)
	echo "$CACHE_DIR/${digest:0:32}.png"
}

get_single_filename() {
	local digest=$(echo $@ | md5sum)
	echo "$CACHE_DIR/${digest:0:32}.png"
}

base_resize() {
	local size="$3"
	eval convert "$1" -resize "$size""^" -gravity center -extent "$size" "$2"
}

apply_dim_effect() {
	local input="$1"
	local output="$2"

	eval convert "$input" \
		-fill black -colorize "$DIM_LEVEL"% \
		"$output"
}

apply_blur_effect() {
	local input="$1"
	local output="$2"
	local size="$3"

	blur_shrink=$(echo "scale=2; 20 / $BLUR_LEVEL" | bc)
	blur_sigma=$(echo "scale=2; 0.6 * $BLUR_LEVEL" | bc)
	eval convert "$input" \
		-filter Gaussian \
		-resize "$blur_shrink%" \
		-define "filter:sigma=$blur_sigma" \
		-resize "$size^" -gravity center -extent "$size" \
		"$output"
}

apply_dimblur_effect() {
	local input="$1"
	local output="$2"
	local size="$3"

	blur_shrink=$(echo "scale=2; 20 / $BLUR_LEVEL" | bc)
	blur_sigma=$(echo "scale=2; 0.6 * $BLUR_LEVEL" | bc)
	eval convert "$input" \
		-fill black -colorize "$DIM_LEVEL"% \
		-filter Gaussian \
		-resize "$blur_shrink%" \
		-define "filter:sigma=$blur_sigma" \
		-resize "$size^" -gravity center -extent "$size" \
		"$output"
}

apply_pixel_effect() {
	local input="$1"
	local output="$2"

	IFS=',' read -ra range <<< "$PIXEL_SCALE"
	eval convert "$input" \
		-scale "${range[0]}"% -scale "${range[1]}"% \
		"$output"
}

apply_dimpixel_effect() {
	local input="$1"
	local output="$2"

	IFS=',' read -ra range <<< "$PIXEL_SCALE"
	eval convert "$input" \
		-fill black -colorize "$DIM_LEVEL"% \
		-scale "${range[0]}"% -scale "${range[1]}"% \
		"$output"
}

apply_color_effect() {
	local output="$1"
	local size="$2"

	eval convert -size "$size" canvas:\#"$SOLID_COLOR" "$output"
}

gen_single_image() {
	local input="$1"
	local target_size="$2"

	local resize_res=$(get_single_filename "$input" none "$target_size")
	if [ ! -f "$resize_res" ]; then
		base_resize "$input" "$resize_res" "$target_size"
	fi

	if [ "$EFFECT" = 'none' ]; then
		echo $resize_res
		exit 0
	fi

	local effect_res=''
	if [ ! -f "$effect_res" ]; then
		case "$EFFECT" in
			dim)
				effect_res=$(get_single_filename "$input" $EFFECT "$target_size" $DIM_LEVEL)
				apply_dim_effect "$resize_res" "$effect_res"
				;;
			blur)
				effect_res=$(get_single_filename "$input" $EFFECT "$target_size" $BLUR_LEVEL)
				apply_blur_effect "$resize_res" "$effect_res" "$target_size"
				;;
			dimblur)
				effect_res=$(get_single_filename "$input" $EFFECT "$target_size" $DIM_LEVEL $BLUR_LEVEL)
				apply_dimblur_effect "$resize_res" "$effect_res" "$target_size"
				;;
			pixel)
				effect_res=$(get_single_filename "$input" $EFFECT "$target_size" $PIXEL_SCALE)
				apply_pixel_effect "$resize_res" "$effect_res"
				;;
			dimpixel)
				effect_res=$(get_single_filename "$input" $EFFECT "$target_size" $DIM_LEVEL $PIXEL_SCALE)
				apply_dimpixel_effect "$resize_res" "$effect_res"
				;;
			color)
				effect_res=$(get_single_filename $EFFECT "$target_size" $SOLID_COLOR)
				apply_color_effect "$effect_res" "$target_size"
				;;

			*)
				# TODO: Print a message about unrecognized effect?
				exit 1
				;;
		esac
	fi

	echo $effect_res
}

compose_singles() {
	local composed=$(get_composed_filename)

	convert -size $TOTAL_SIZE 'xc:blue' "$composed"

	local compose_param=()
	for ((i = 0; i < ${#IMAGE_PATHS[@]}; ++i)); do
		local image="${IMAGE_PATHS[$i]}"
		local geometry="${DISPLAY_OFFSETS[$i]}"
		compose_param+=("$compose_param" "$image" -geometry "$geometry" -composite)
	done
	convert "$composed" "${compose_param[@]}" "$composed"
	echo $composed
}

gen_lock_image() {
	for ((i = 0; i < ${#IMAGE_PATHS[@]}; ++i)); do
		local image="${IMAGE_PATHS[$i]}"
		local target_size="${DISPLAY_SIZES[$i]}"
		PROCESSED_SINGLES+=("$(gen_single_image "$image" "$target_size")")
	done

	if [ "${#IMAGE_PATHS[@]}" -eq 1 ]; then
		echo ${PROCESSED_SINGLES[0]}
	else
		compose_singles
	fi
}

verify_args() {
	# TODO: verify cache dir is specified
	mkdir -p "$CACHE_DIR"

	if [ "${#IMAGE_PATHS[@]}" -ne "${#DISPLAY_SIZES[@]}" ]; then
		# For now, only support the case where the number of images and displays are
		# equal, which is what the multilockscreen calling script enforces.
		# TODO: Add error msg
		# TODO: We could be more clever here? If we have more images than displays,
		# use a random subset?
		exit 1
	fi

	# TODO: Verify passed in images all exist
}

for arg in "$@"; do
	[[ "${arg:0:1}" = '-' ]] || continue

	case "$1" in
		--cachedir)
			CACHE_DIR="$2"
			shift 2
			;;

		--img)
			IMAGE_PATHS+=("$2")
			shift 2
			;;

		--display)
			DISPLAY_SIZES+=("$2")
			DISPLAY_OFFSETS+=("$3")
			shift 3
			;;

		--effect)
			EFFECT="$2"
			shift 2
			;;

		--totalsize)
			TOTAL_SIZE="$2"
			shift 2
			;;

		--dim)
			DIM_LEVEL="$2"
			shift 2
			;;

		--blur)
			BLUR_LEVEL="$2"
			shift 2
			;;

		--pixel)
			PIXEL_SCALE="$2"
			shift 2
			;;

		--color)
			SOLID_COLOR="${2//\#/}"
			shift 2
			;;

		-h | --help | *)
			# TODO: Add usage info
			exit 0
			;;
	esac
done

verify_args
gen_lock_image
